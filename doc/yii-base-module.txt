
*yii/base/Module*   >> |yii/di/ServiceLocator|
=================

SUBCLASSES
------------------------------------------------------------------------------

|yii/base/Application|
|yii/web/Application|
|yii/console/Application|
|yii/debug/Module|
|yii/gii/Module|

DESCRIPTION
------------------------------------------------------------------------------

 A module represents a sub-application which contains MVC elements by itself,
 such as models, views, controllers, etc.

 A module may consist of 'modules|sub-modules'.

 'components|Components' may be registered with the module so that they are
 globally accessible within the module.


PROPERTY DETAILS
------------------------------------------------------------------------------

$params					*yii/base/Module::$params*

 (array) Custom module parameters (name => value).

$id					*yii/base/Module::$id*

 (string) An ID that uniquely identifies this module among other modules which
 have the same 'module|parent'.

$module					*yii/base/Module::$module*

 (\yii\base\Module) The parent module of this module. Null if this module does
 not have a parent.

$layout					*yii/base/Module::$layout*

 (string|boolean) The layout that should be applied for views within this
 module. This refers to a view name relative to 'layoutPath'. If this is not
 set, it means the layout value of the 'module|parent module' will be taken.
 If this is false, layout will be disabled within this module.

$controllerMap				*yii/base/Module::$controllerMap*

 (array) Mapping from controller ID to controller configurations. Each
 name-value pair specifies the configuration of a single controller. A
 controller configuration can be either a string or an array. If the former,
 the string should be the fully qualified class name of the controller. If the
 latter, the array must contain a 'class' element which specifies the
 controller's fully qualified class name, and the rest of the name-value pairs
 in the array are used to initialize the corresponding controller properties.
 For example,

   [
     'account' => 'app\controllers\UserController',
     'article' => [
        'class' => 'app\controllers\PostController',
        'pageTitle' => 'something new',
     ],
   ]



$controllerNamespace			*yii/base/Module::$controllerNamespace*

 (string) The namespace that controller classes are in. This namespace will be
 used to load controller classes by prepending it to the controller class
 name.

 If not set, it will use the 'controllers' sub-namespace under the namespace
 of this module. For example, if the namespace of this module is "foo\bar",
 then the default controller namespace would be "foo\bar\controllers".

 See also the [guide section on autoloading](guide:concept-autoloading) to
 learn more about defining namespaces and how classes are loaded.

$defaultRoute				*yii/base/Module::$defaultRoute*

 (string) The default route of this module. Defaults to 'default'. The route
 may consist of child module ID, controller ID, and/or action ID. For example,
 'help', 'post/create', 'admin/post/create'. If action ID is not given, it
 will take the default value as specified in 'Controller::defaultAction'.

$behaviors				*yii/base/Module::$behaviors*

 See |yii/base/Component::$behaviors|

$components				*yii/base/Module::$components*

 See |yii/di/ServiceLocator::$components|

$uniqueId				*yii/base/Module::$uniqueId*

 (string) The unique ID of the module.

$basePath				*yii/base/Module::$basePath*

 (string) The root directory of the module.

$controllerPath				*yii/base/Module::$controllerPath*

 (string) The directory that contains the controller classes.

$viewPath				*yii/base/Module::$viewPath*

 (string) The root directory of view files. Defaults to "'basePath'/views".

$layoutPath				*yii/base/Module::$layoutPath*

 (string) The root directory of layout files. Defaults to
 "'viewPath'/layouts".

$aliases				*yii/base/Module::$aliases*

 (array) List of path aliases to be defined. The array keys are alias names
 (must start with '@') and the array values are the corresponding paths or
 aliases. For example,

   [
       '@models' => '@app/models', // an existing alias
       '@backend' => __DIR__ . '/../backend',  // a directory
   ]



$modules				*yii/base/Module::$modules*

 (array) The modules (indexed by their IDs)



METHOD DETAILS
------------------------------------------------------------------------------


*yii/base/Module::className*				public

 See |yii/base/Object::className|


*yii/base/Module::__construct*				public
>
 __construct($id, $parent='null', $config='[]')
<
return (void)

    [$id] (string) The ID of this module
    [$parent] (\yii\base\Module) The parent module (if any)
    [$config] (array) Name-value pairs that will be used to initialize the
    object properties


*yii/base/Module::init*					public
>
 init()
<
return (void)

 This method is called after the module is created and initialized with
 property values given in configuration. The default implementation will
 initialize 'controllerNamespace' if it is not set.

 If you override this method, please make sure you call the parent
 implementation.


*yii/base/Module::__get*					public

 See |yii/di/ServiceLocator::__get|


*yii/base/Module::__set*					public

 See |yii/base/Object::__set|


*yii/base/Module::__isset*				public

 See |yii/di/ServiceLocator::__isset|


*yii/base/Module::__unset*				public

 See |yii/base/Object::__unset|


*yii/base/Module::__call*					public

 See |yii/base/Object::__call|


*yii/base/Module::hasProperty*				public

 See |yii/base/Object::hasProperty|


*yii/base/Module::canGetProperty*				public

 See |yii/base/Object::canGetProperty|


*yii/base/Module::canSetProperty*				public

 See |yii/base/Object::canSetProperty|


*yii/base/Module::hasMethod*				public

 See |yii/base/Object::hasMethod|


*yii/base/Module::__clone*				public

 See |yii/base/Component::__clone|


*yii/base/Module::behaviors*				public

 See |yii/base/Component::behaviors|


*yii/base/Module::hasEventHandlers*			public

 See |yii/base/Component::hasEventHandlers|


*yii/base/Module::on*					public

 See |yii/base/Component::on|


*yii/base/Module::off*					public

 See |yii/base/Component::off|


*yii/base/Module::trigger*				public

 See |yii/base/Component::trigger|


*yii/base/Module::getBehavior*				public

 See |yii/base/Component::getBehavior|


*yii/base/Module::getBehaviors*				public

 See |yii/base/Component::getBehaviors|


*yii/base/Module::attachBehavior*				public

 See |yii/base/Component::attachBehavior|


*yii/base/Module::attachBehaviors*			public

 See |yii/base/Component::attachBehaviors|


*yii/base/Module::detachBehavior*				public

 See |yii/base/Component::detachBehavior|


*yii/base/Module::detachBehaviors*			public

 See |yii/base/Component::detachBehaviors|


*yii/base/Module::ensureBehaviors*			public

 See |yii/base/Component::ensureBehaviors|


*yii/base/Module::has*					public

 See |yii/di/ServiceLocator::has|


*yii/base/Module::get*					public

 See |yii/di/ServiceLocator::get|


*yii/base/Module::set*					public

 See |yii/di/ServiceLocator::set|


*yii/base/Module::clear*					public

 See |yii/di/ServiceLocator::clear|


*yii/base/Module::getComponents*				public

 See |yii/di/ServiceLocator::getComponents|


*yii/base/Module::setComponents*				public

 See |yii/di/ServiceLocator::setComponents|


*yii/base/Module::getInstance*				public
>
 getInstance()
<
return (static|null) The currently requested instance of this module class, or null
if the module class is not requested.

 If the module class is not currently requested, null will be returned. This
 method is provided so that you access the module instance from anywhere
 within the module.


*yii/base/Module::setInstance*				public
>
 setInstance($instance)
<
return (void)

    [$instance] (\yii\base\Module|null) The currently requested instance of
    this module class. If it is null, the instance of the calling class will
    be removed, if any.


*yii/base/Module::getUniqueId*				public
>
 getUniqueId()
<
return (string) The unique ID of the module.

 Note that if the module is an application, an empty string will be returned.


*yii/base/Module::getBasePath*				public
>
 getBasePath()
<
return (string) The root directory of the module.

 It defaults to the directory containing the module class file.


*yii/base/Module::setBasePath*				public
>
 setBasePath($path)
<
return (void)

 This method can only be invoked at the beginning of the constructor.

    [$path] (string) The root directory of the module. This can be either a
    directory name or a path alias.


*yii/base/Module::getControllerPath*			public
>
 getControllerPath()
<
return (string) The directory that contains the controller classes.

 Note that in order for this method to return a value, you must define an
 alias for the root namespace of 'controllerNamespace'.


*yii/base/Module::getViewPath*				public
>
 getViewPath()
<
return (string) The root directory of view files. Defaults to "'basePath'/views".



*yii/base/Module::setViewPath*				public
>
 setViewPath($path)
<
return (void)

    [$path] (string) The root directory of view files.


*yii/base/Module::getLayoutPath*				public
>
 getLayoutPath()
<
return (string) The root directory of layout files. Defaults to "'viewPath'/layouts".



*yii/base/Module::setLayoutPath*				public
>
 setLayoutPath($path)
<
return (void)

    [$path] (string) The root directory or path alias of layout files.


*yii/base/Module::setAliases*				public
>
 setAliases($aliases)
<
return (void)

 This method calls 'Yii::setAlias()' to register the path aliases. This method
 is provided so that you can define path aliases when configuring a module.

    [$aliases] (array) List of path aliases to be defined. The array keys are
    alias names (must start with '@') and the array values are the
    corresponding paths or aliases. For example,

      [
          '@models' => '@app/models', // an existing alias
          '@backend' => __DIR__ . '/../backend',  // a directory
      ]




*yii/base/Module::hasModule*				public
>
 hasModule($id)
<
return (boolean) Whether the named module exists. Both loaded and unloaded modules
are considered.

 This method supports checking the existence of both child and grand child
 modules.

    [$id] (string) Module ID. For grand child modules, use ID path relative to
    this module (e.g. 'admin/content').


*yii/base/Module::getModule*				public
>
 getModule($id, $load='true')
<
return (\yii\base\Module|null) The module instance, null if the module does not
exist.

 This method supports retrieving both child modules and grand child modules.

    [$id] (string) Module ID (case-sensitive). To retrieve grand child
    modules, use ID path relative to this module (e.g. 'admin/content').
    [$load] (boolean) Whether to load the module if it is not yet loaded.


*yii/base/Module::setModule*				public
>
 setModule($id, $module)
<
return (void)

    [$id] (string) Module ID
    [$module] (\yii\base\Module|array|null) The sub-module to be added to this
    module. This can be one of the following:


      - a 'Module' object 
      - a configuration array: when 'getModule()' is called initially, the
      array   will be used to instantiate the sub-module 
      - null: the named sub-module will be removed from this module


*yii/base/Module::getModules*				public
>
 getModules($loadedOnly='false')
<
return (array) The modules (indexed by their IDs)

    [$loadedOnly] (boolean) Whether to return the loaded sub-modules only. If
    this is set false, then all sub-modules registered in this module will be
    returned, whether they are loaded or not. Loaded modules will be returned
    as objects, while unloaded modules as configuration arrays.


*yii/base/Module::setModules*				public
>
 setModules($modules)
<
return (void)

 Each sub-module should be specified as a name-value pair, where name refers
 to the ID of the module and value the module or a configuration array that
 can be used to create the module. In the latter case, 'Yii::createObject()'
 will be used to create the module.

 If a new sub-module has the same ID as an existing one, the existing one will
 be overwritten silently.

 The following is an example for registering two sub-modules:

   [
       'comment' => [
           'class' => 'app\modules\comment\CommentModule',
           'db' => 'db',
       ],
       'booking' => ['class' => 'app\modules\booking\BookingModule'],
   ]



    [$modules] (array) Modules (id => module configuration or instances)


*yii/base/Module::runAction*				public
>
 runAction($route, $params='[]')
<
return (mixed) The result of the action.

 This method parses the specified route and creates the corresponding child
 module(s), controller and action instances. It then calls
 'Controller::runAction()' to run the action with the given parameters. If the
 route is empty, the method will use 'defaultRoute'.

    [$route] (string) The route that specifies the action.
    [$params] (array) The parameters to be passed to the action


*yii/base/Module::createController*			public
>
 createController($route)
<
return (array|boolean) If the controller is created successfully, it will be returned
together with the requested action ID. Otherwise false will be returned.

 The route should be relative to this module. The method implements the
 following algorithm to resolve the given route:

 1. If the route is empty, use 'defaultRoute'; 2. If the first segment of the
 route is a valid module ID as declared in 'modules',    call the module's
 'createController()' with the rest part of the route; 3. If the first segment
 of the route is found in 'controllerMap', create a controller    based on the
 corresponding configuration found in 'controllerMap'; 4. The given route is
 in the format of 'abc/def/xyz'. Try either 'abc\DefController'    or
 'abc\def\XyzController' class within the 'controllerNamespace|controller
 namespace'.

 If any of the above steps resolves into a controller, it is returned together
 with the rest part of the route which will be treated as the action ID.
 Otherwise, false will be returned.

    [$route] (string) The route consisting of module, controller and action
    IDs.


*yii/base/Module::createControllerByID*			public
>
 createControllerByID($id)
<
return (\yii\base\Controller) The newly created controller instance, or null if the
controller ID is invalid.

 The controller ID is relative to this module. The controller class should be
 namespaced under 'controllerNamespace'.

 Note that this method does not check 'modules' or 'controllerMap'.

    [$id] (string) The controller ID


*yii/base/Module::beforeAction*				public
>
 beforeAction($action)
<
return (boolean) Whether the action should continue to be executed.

 The method will trigger the 'EVENT_BEFORE_ACTION' event. The return value of
 the method will determine whether the action should continue to run.

 In case the action should not run, the request should be handled inside of
 the 'beforeAction' code by either providing the necessary output or
 redirecting the request. Otherwise the response will be empty.

 If you override this method, your code should look like the following:

   public function beforeAction($action)
   {
       if (!parent::beforeAction($action)) {
           return false;
       }

       // your custom code here

       return true; // or false to not run the action
   }



    [$action] (\yii\base\Action) The action to be executed.


*yii/base/Module::afterAction*				public
>
 afterAction($action, $result)
<
return (mixed) The processed action result.

 The method will trigger the 'EVENT_AFTER_ACTION' event. The return value of
 the method will be used as the action return value.

 If you override this method, your code should look like the following:

   public function afterAction($action, $result)
   {
       $result = parent::afterAction($action, $result);
       // your custom code here
       return $result;
   }



    [$action] (\yii\base\Action) The action just executed.
    [$result] (mixed) The action return result.



 vim:tw=78:ts=8:ft=help:norl:
