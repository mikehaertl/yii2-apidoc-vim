
*yii/web/Request*   >> |yii/base/Request|
=================

DESCRIPTION
------------------------------------------------------------------------------

 It encapsulates the $_SERVER variable and resolves its inconsistency among
 different Web servers. Also it provides an interface to retrieve request
 parameters from $_POST, $_GET, $_COOKIES and REST parameters sent via other
 HTTP methods like PUT or DELETE.

 Request is configured as an application component in '\yii\web\Application'
 by default. You can access that instance via 'Yii::$app->request'.

 For more details and usage information on Request, see the [guide article on
 requests](guide:runtime-requests).


PROPERTY DETAILS
------------------------------------------------------------------------------

$enableCsrfValidation			*yii/web/Request::$enableCsrfValidation*

 (bool) Whether to enable CSRF (Cross-Site Request Forgery) validation.
 Defaults to true. When CSRF validation is enabled, forms submitted to an Yii
 Web application must be originated from the same application. If not, a 400
 HTTP exception will be raised.

 Note, this feature requires that the user client accepts cookie. Also, to use
 this feature, forms submitted via POST method must contain a hidden input
 whose name is specified by 'csrfParam'. You may use
 '\yii\helpers\Html::beginForm()' to generate his hidden input.

 In JavaScript, you may get the values of 'csrfParam' and 'csrfToken' via
 'yii.getCsrfParam()' and 'yii.getCsrfToken()', respectively. The
 '\yii\web\YiiAsset' asset must be registered. You also need to include CSRF
 meta tags in your pages by using '\yii\helpers\Html::csrfMetaTags()'.

$csrfParam				*yii/web/Request::$csrfParam*

 (string) The name of the token used to prevent CSRF. Defaults to '_csrf'.
 This property is used only when 'enableCsrfValidation' is true.

$csrfCookie				*yii/web/Request::$csrfCookie*

 (array) The configuration for creating the CSRF 'Cookie|cookie'. This
 property is used only when both 'enableCsrfValidation' and 'enableCsrfCookie'
 are true.

$enableCsrfCookie			*yii/web/Request::$enableCsrfCookie*

 (bool) Whether to use cookie to persist CSRF token. If false, CSRF token will
 be stored in session under the name of 'csrfParam'. Note that while storing
 CSRF tokens in session increases security, it requires starting a session for
 every page, which will degrade your site performance.

$enableCookieValidation			*yii/web/Request::$enableCookieValidation*

 (bool) Whether cookies should be validated to ensure they are not tampered.
 Defaults to true.

$cookieValidationKey			*yii/web/Request::$cookieValidationKey*

 (string) A secret key used for cookie validation. This property must be set
 if 'enableCookieValidation' is true.

$methodParam				*yii/web/Request::$methodParam*

 (string) The name of the POST parameter that is used to indicate if a request
 is a PUT, PATCH or DELETE request tunneled through POST. Defaults to
 '_method'.

$parsers				*yii/web/Request::$parsers*

 (array) The parsers for converting the raw HTTP request body into
 'bodyParams'. The array keys are the request 'Content-Types', and the array
 values are the corresponding configurations for 'Yii::createObject|creating
 the parser objects'. A parser must implement the 'RequestParserInterface'.

 To enable parsing for JSON requests you can use the 'JsonParser' class like
 in the following example:

 ''' [     'application/json' => 'yii\web\JsonParser', ] '''

 To register a parser for parsing all request types you can use ''*'' as the
 array key. This one will be used as a fallback in case no other types match.

$trustedHosts				*yii/web/Request::$trustedHosts*

 (array) The configuration for trusted security related headers.

 An array key is an IPv4 or IPv6 IP address in CIDR notation for matching a
 client.

 An array value is a list of headers to trust. These will be matched against
 'secureHeaders' to determine which headers are allowed to be sent by a
 specified host. The case of the header names must be the same as specified in
 'secureHeaders'.

 For example, to trust all headers listed in 'secureHeaders' for IP addresses
 in range '192.168.0.0-192.168.0.254' write the following:

   [
       '192.168.0.0/24',
   ]

 To trust just the 'X-Forwarded-For' header from '10.0.0.1', use:

 ''' [     '10.0.0.1' => ['X-Forwarded-For'] ] '''

 Default is to trust all headers except those listed in 'secureHeaders' from
 all hosts. Matches are tried in order and searching is stopped when IP
 matches.

 > Info: Matching is performed using 'IpValidator'.   See
 'IpValidator::::setRanges()|IpValidator::setRanges()'   and
 'IpValidator::networks' for advanced matching.

$secureHeaders				*yii/web/Request::$secureHeaders*

 (array) Lists of headers that are, by default, subject to the trusted host
 configuration. These headers will be filtered unless explicitly allowed in
 'trustedHosts'. The match of header names is case-insensitive.

$ipHeaders				*yii/web/Request::$ipHeaders*

 (string[]) List of headers where proxies store the real client IP. It's not
 advisable to put insecure headers here. The match of header names is
 case-insensitive.

$secureProtocolHeaders			*yii/web/Request::$secureProtocolHeaders*

 (array) List of headers to check for determining whether the connection is
 made via HTTPS. The array keys are header names and the array value is a list
 of header values that indicate a secure connection. The match of header names
 and values is case-insensitive. It's not advisable to put insecure headers
 here.



METHOD DETAILS
------------------------------------------------------------------------------


*yii/web/Request::className*				public

 See |yii/base/BaseObject::className|


*yii/web/Request::__construct*				public

 See |yii/base/BaseObject::__construct|


*yii/web/Request::init*					public

 See |yii/base/BaseObject::init|


*yii/web/Request::__get*					public

 See |yii/base/Component::__get|


*yii/web/Request::__set*					public

 See |yii/base/Component::__set|


*yii/web/Request::__isset*				public

 See |yii/base/Component::__isset|


*yii/web/Request::__unset*				public

 See |yii/base/Component::__unset|


*yii/web/Request::__call*					public

 See |yii/base/Component::__call|


*yii/web/Request::hasProperty*				public

 See |yii/base/Component::hasProperty|


*yii/web/Request::canGetProperty*				public

 See |yii/base/Component::canGetProperty|


*yii/web/Request::canSetProperty*				public

 See |yii/base/Component::canSetProperty|


*yii/web/Request::hasMethod*				public

 See |yii/base/Component::hasMethod|


*yii/web/Request::__clone*				public

 See |yii/base/Component::__clone|


*yii/web/Request::behaviors*				public

 See |yii/base/Component::behaviors|


*yii/web/Request::hasEventHandlers*			public

 See |yii/base/Component::hasEventHandlers|


*yii/web/Request::on*					public

 See |yii/base/Component::on|


*yii/web/Request::off*					public

 See |yii/base/Component::off|


*yii/web/Request::trigger*				public

 See |yii/base/Component::trigger|


*yii/web/Request::getBehavior*				public

 See |yii/base/Component::getBehavior|


*yii/web/Request::getBehaviors*				public

 See |yii/base/Component::getBehaviors|


*yii/web/Request::attachBehavior*				public

 See |yii/base/Component::attachBehavior|


*yii/web/Request::attachBehaviors*			public

 See |yii/base/Component::attachBehaviors|


*yii/web/Request::detachBehavior*				public

 See |yii/base/Component::detachBehavior|


*yii/web/Request::detachBehaviors*			public

 See |yii/base/Component::detachBehaviors|


*yii/web/Request::ensureBehaviors*			public

 See |yii/base/Component::ensureBehaviors|


*yii/web/Request::resolve*				public
>
 resolve()
<
return (array) The first element is the route, and the second is the associated
parameters.



*yii/web/Request::getIsConsoleRequest*			public

 See |yii/base/Request::getIsConsoleRequest|


*yii/web/Request::setIsConsoleRequest*			public

 See |yii/base/Request::setIsConsoleRequest|


*yii/web/Request::getScriptFile*				public
>
 getScriptFile()
<
return (string) The entry script file path

 The default implementation will simply return '$_SERVER['SCRIPT_FILENAME']'.


*yii/web/Request::setScriptFile*				public
>
 setScriptFile($value)
<
return (void)

 The entry script file path normally can be obtained from
 '$_SERVER['SCRIPT_FILENAME']'. If your server configuration does not return
 the correct value, you may configure this property to make it right.

    [$value] (string) The entry script file path.


*yii/web/Request::filterHeaders*				protected
>
 filterHeaders($headerCollection)
<
return (void)

    [$headerCollection] (\yii\web\HeaderCollection) 


*yii/web/Request::getIpValidator*				protected
>
 getIpValidator()
<
return (\yii\validators\IpValidator) 

 You can override this method to adjust validator or implement different
 matching strategy.


*yii/web/Request::getHeaders*				public
>
 getHeaders()
<
return (\yii\web\HeaderCollection) The header collection

 The header collection contains incoming HTTP headers.


*yii/web/Request::getMethod*				public
>
 getMethod()
<
return (string) Request method, such as GET, POST, HEAD, PUT, PATCH, DELETE. The
value returned is turned into upper case.



*yii/web/Request::getIsGet*				public
>
 getIsGet()
<
return (bool) Whether this is a GET request.



*yii/web/Request::getIsOptions*				public
>
 getIsOptions()
<
return (bool) Whether this is a OPTIONS request.



*yii/web/Request::getIsHead*				public
>
 getIsHead()
<
return (bool) Whether this is a HEAD request.



*yii/web/Request::getIsPost*				public
>
 getIsPost()
<
return (bool) Whether this is a POST request.



*yii/web/Request::getIsDelete*				public
>
 getIsDelete()
<
return (bool) Whether this is a DELETE request.



*yii/web/Request::getIsPut*				public
>
 getIsPut()
<
return (bool) Whether this is a PUT request.



*yii/web/Request::getIsPatch*				public
>
 getIsPatch()
<
return (bool) Whether this is a PATCH request.



*yii/web/Request::getIsAjax*				public
>
 getIsAjax()
<
return (bool) Whether this is an AJAX (XMLHttpRequest) request.

 Note that jQuery doesn't set the header in case of cross domain requests:
 https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header


*yii/web/Request::getIsPjax*				public
>
 getIsPjax()
<
return (bool) Whether this is a PJAX request



*yii/web/Request::getIsFlash*				public
>
 getIsFlash()
<
return (bool) Whether this is an Adobe Flash or Adobe Flex request.



*yii/web/Request::getRawBody*				public
>
 getRawBody()
<
return (string) The request body



*yii/web/Request::setRawBody*				public
>
 setRawBody($rawBody)
<
return (void)

    [$rawBody] (string) The request body


*yii/web/Request::getBodyParams*				public
>
 getBodyParams()
<
return (array) The request parameters given in the request body.

 Request parameters are determined using the parsers configured in 'parsers'
 property. If no parsers are configured for the current 'contentType' it uses
 the PHP function 'mb_parse_str()' to parse the 'rawBody|request body'.


*yii/web/Request::setBodyParams*				public
>
 setBodyParams($values)
<
return (void)

    [$values] (array) The request body parameters (name-value pairs)


*yii/web/Request::getBodyParam*				public
>
 getBodyParam($name, $defaultValue='null')
<
return (mixed) The parameter value

 If the parameter does not exist, the second parameter passed to this method
 will be returned.

    [$name] (string) The parameter name
    [$defaultValue] (mixed) The default parameter value if the parameter does
    not exist.


*yii/web/Request::post*					public
>
 post($name='null', $defaultValue='null')
<
return (array|mixed) 

    [$name] (string) The parameter name
    [$defaultValue] (mixed) The default parameter value if the parameter does
    not exist.


*yii/web/Request::getQueryParams*				public
>
 getQueryParams()
<
return (array) The request GET parameter values.

 This method will return the contents of '$_GET' if params where not
 explicitly set.


*yii/web/Request::setQueryParams*				public
>
 setQueryParams($values)
<
return (void)

    [$values] (array) The request query parameters (name-value pairs)


*yii/web/Request::get*					public
>
 get($name='null', $defaultValue='null')
<
return (array|mixed) 

    [$name] (string) The parameter name
    [$defaultValue] (mixed) The default parameter value if the parameter does
    not exist.


*yii/web/Request::getQueryParam*				public
>
 getQueryParam($name, $defaultValue='null')
<
return (mixed) The GET parameter value

 If the GET parameter does not exist, the second parameter passed to this
 method will be returned.

    [$name] (string) The GET parameter name.
    [$defaultValue] (mixed) The default parameter value if the GET parameter
    does not exist.


*yii/web/Request::getHostInfo*				public
>
 getHostInfo()
<
return (string|null) Schema and hostname part (with port number if needed) of the
request URL (e.g. 'http://www.yiiframework.com'), null if can't be obtained
from '$_SERVER' and wasn't set.

 The returned URL does not have an ending slash.

 By default this value is based on the user request information. This method
 will return the value of '$_SERVER['HTTP_HOST']' if it is available or
 '$_SERVER['SERVER_NAME']' if not. You may want to check out the [PHP
 documentation](http://php.net/manual/en/reserved.variables.server.php) for
 more information on these variables.

 You may explicitly specify it by setting the 'setHostInfo()|hostInfo'
 property.

 > Warning: Dependent on the server configuration this information may not be
 > reliable and [may be faked by the user sending the HTTP
 request](https://www.acunetix.com/vulnerabilities/web/host-header-attack). >
 If the webserver is configured to serve the same site independent of the
 value of > the 'Host' header, this value is not reliable. In such situations
 you should either > fix your webserver configuration or explicitly set the
 value by setting the 'setHostInfo()|hostInfo' property. > If you don't have
 access to the server configuration, you can setup '\yii\filters\HostControl'
 filter at > application level in order to protect against such kind of
 attack.


*yii/web/Request::setHostInfo*				public
>
 setHostInfo($value)
<
return (void)

 This setter is provided in case the schema and hostname cannot be determined
 on certain Web servers.

    [$value] (string|null) The schema and host part of the application URL.
    The trailing slashes will be removed.


*yii/web/Request::getHostName*				public
>
 getHostName()
<
return (string|null) Hostname part of the request URL (e.g. 'www.yiiframework.com')

 Value is calculated from current 'getHostInfo()|hostInfo' property.

 > Warning: The content of this value may not be reliable, dependent on the
 server > configuration. Please refer to 'getHostInfo()' for more information.


*yii/web/Request::getBaseUrl*				public
>
 getBaseUrl()
<
return (string) The relative URL for the application

 This is similar to 'scriptUrl' except that it does not include the script
 file name, and the ending slashes are removed.


*yii/web/Request::setBaseUrl*				public
>
 setBaseUrl($value)
<
return (void)

 By default the URL is determined based on the entry script URL. This setter
 is provided in case you want to change this behavior.

    [$value] (string) The relative URL for the application


*yii/web/Request::getScriptUrl*				public
>
 getScriptUrl()
<
return (string) The relative URL of the entry script.

 The implementation of this method referenced Zend_Controller_Request_Http in
 Zend Framework.


*yii/web/Request::setScriptUrl*				public
>
 setScriptUrl($value)
<
return (void)

 This setter is provided in case the entry script URL cannot be determined on
 certain Web servers.

    [$value] (string) The relative URL for the application entry script.


*yii/web/Request::getPathInfo*				public
>
 getPathInfo()
<
return (string) Part of the request URL that is after the entry script and before the
question mark. Note, the returned path info is already URL-decoded.

 A path info refers to the part that is after the entry script and before the
 question mark (query string). The starting and ending slashes are both
 removed.


*yii/web/Request::setPathInfo*				public
>
 setPathInfo($value)
<
return (void)

 This method is mainly provided for testing purpose.

    [$value] (string) The path info of the current request


*yii/web/Request::resolvePathInfo*			protected
>
 resolvePathInfo()
<
return (string) Part of the request URL that is after the entry script and before the
question mark. Note, the returned path info is decoded.

 A path info refers to the part that is after the entry script and before the
 question mark (query string). The starting slashes are both removed (ending
 slashes will be kept).


*yii/web/Request::getAbsoluteUrl*				public
>
 getAbsoluteUrl()
<
return (string) The currently requested absolute URL.

 This is a shortcut to the concatenation of 'hostInfo' and 'url'.


*yii/web/Request::getUrl*					public
>
 getUrl()
<
return (string) The currently requested relative URL. Note that the URI returned may
be URL-encoded depending on the client.

 This refers to the portion of the URL that is after the 'hostInfo' part. It
 includes the 'queryString' part if any.


*yii/web/Request::setUrl*					public
>
 setUrl($value)
<
return (void)

 The URI must refer to the portion that is after 'hostInfo'. Note that the URI
 should be URL-encoded.

    [$value] (string) The request URI to be set


*yii/web/Request::resolveRequestUri*			protected
>
 resolveRequestUri()
<
return (string|bool) The request URI portion for the currently requested URL. Note
that the URI returned may be URL-encoded depending on the client.

 This refers to the portion that is after the 'hostInfo' part. It includes the
 'queryString' part if any. The implementation of this method referenced
 Zend_Controller_Request_Http in Zend Framework.


*yii/web/Request::getQueryString*				public
>
 getQueryString()
<
return (string) Part of the request URL that is after the question mark



*yii/web/Request::getIsSecureConnection*			public
>
 getIsSecureConnection()
<
return (bool) If the request is sent via secure channel (https)



*yii/web/Request::getServerName*				public
>
 getServerName()
<
return (string) Server name, null if not available



*yii/web/Request::getServerPort*				public
>
 getServerPort()
<
return (int|null) Server port number, null if not available



*yii/web/Request::getReferrer*				public
>
 getReferrer()
<
return (string|null) URL referrer, null if not available



*yii/web/Request::getOrigin*				public
>
 getOrigin()
<
return (string|null) URL origin of a CORS request, 'null' if not available.

 The return value is taken from the 'Origin' 'getHeaders()|header' sent by the
 browser.

 Note that the origin request header indicates where a fetch originates from.
 It doesn't include any path information, but only the server name. It is sent
 with a CORS requests, as well as with POST requests. It is similar to the
 referer header, but, unlike this header, it doesn't disclose the whole path.
 Please refer to
 <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin> for more
 information.


*yii/web/Request::getUserAgent*				public
>
 getUserAgent()
<
return (string|null) User agent, null if not available



*yii/web/Request::getUserIP*				public
>
 getUserIP()
<
return (string|null) User IP address, null if not available

 The IP is determined using headers and / or '$_SERVER' variables.


*yii/web/Request::getUserHost*				public
>
 getUserHost()
<
return (string|null) User host name, null if not available

 The HOST is determined using headers and / or '$_SERVER' variables.


*yii/web/Request::getRemoteIP*				public
>
 getRemoteIP()
<
return (string|null) Remote IP address, 'null' if not available.

 This is always the next hop, any headers are ignored.


*yii/web/Request::getRemoteHost*				public
>
 getRemoteHost()
<
return (string|null) Remote host name, 'null' if not available

 This is always the next hop, any headers are ignored.


*yii/web/Request::getAuthUser*				public
>
 getAuthUser()
<
return (string|null) The username sent via HTTP authentication, 'null' if the
username is not given



*yii/web/Request::getAuthPassword*			public
>
 getAuthPassword()
<
return (string|null) The password sent via HTTP authentication, 'null' if the
password is not given



*yii/web/Request::getAuthCredentials*			public
>
 getAuthCredentials()
<
return (array) That contains exactly two elements: 
  - 0: the username sent via HTTP authentication, 'null' if the
  username is not given 
  - 1: the password sent via HTTP authentication, 'null' if the
  password is not given



*yii/web/Request::getPort*				public
>
 getPort()
<
return (int) Port number for insecure requests.

 Defaults to 80, or the port specified by the server if the current request is
 insecure.


*yii/web/Request::setPort*				public
>
 setPort($value)
<
return (void)

 This setter is provided in case a custom port is necessary for certain server
 configurations.

    [$value] (int) Port number.


*yii/web/Request::getSecurePort*				public
>
 getSecurePort()
<
return (int) Port number for secure requests.

 Defaults to 443, or the port specified by the server if the current request
 is secure.


*yii/web/Request::setSecurePort*				public
>
 setSecurePort($value)
<
return (void)

 This setter is provided in case a custom port is necessary for certain server
 configurations.

    [$value] (int) Port number.


*yii/web/Request::getAcceptableContentTypes*		public
>
 getAcceptableContentTypes()
<
return (array) The content types ordered by the quality score. Types with the highest
scores will be returned first. The array keys are the content types, while the
array values are the corresponding quality score and other parameters as given
in the header.

 This is determined by the 'Accept' HTTP header. For example,

   $_SERVER['HTTP_ACCEPT'] = 'text/plain; q=0.5, application/json;
 version=1.0, application/xml; version=2.0;';
   $types = $request->getAcceptableContentTypes();
   print_r($types);
   // displays:
   // [
   //     'application/json' => ['q' => 1, 'version' => '1.0'],
   //      'application/xml' => ['q' => 1, 'version' => '2.0'],
   //           'text/plain' => ['q' => 0.5],
   // ]




*yii/web/Request::setAcceptableContentTypes*		public
>
 setAcceptableContentTypes($value)
<
return (void)

 Please refer to 'getAcceptableContentTypes()' on the format of the parameter.

    [$value] (array) The content types that are acceptable by the end user.
    They should be ordered by the preference level.


*yii/web/Request::getContentType*				public
>
 getContentType()
<
return (string) Request content-type. Null is returned if this information is not
available.

 For the MIME-types the user expects in response, see
 'acceptableContentTypes'.


*yii/web/Request::getAcceptableLanguages*			public
>
 getAcceptableLanguages()
<
return (array) The languages ordered by the preference level. The first element
represents the most preferred language.

 This is determined by the 'Accept-Language' HTTP header.


*yii/web/Request::setAcceptableLanguages*			public
>
 setAcceptableLanguages($value)
<
return (void)

    [$value] (array) The languages that are acceptable by the end user. They
    should be ordered by the preference level.


*yii/web/Request::parseAcceptHeader*			public
>
 parseAcceptHeader($header)
<
return (array) The acceptable values ordered by their quality score. The values with
the highest scores will be returned first.

 This method will return the acceptable values with their quality scores and
 the corresponding parameters as specified in the given 'Accept' header. The
 array keys of the return value are the acceptable values, while the array
 values consisting of the corresponding quality scores and parameters. The
 acceptable values with the highest quality scores will be returned first. For
 example,

   $header = 'text/plain; q=0.5, application/json; version=1.0,
 application/xml; version=2.0;';
   $accepts = $request->parseAcceptHeader($header);
   print_r($accepts);
   // displays:
   // [
   //     'application/json' => ['q' => 1, 'version' => '1.0'],
   //      'application/xml' => ['q' => 1, 'version' => '2.0'],
   //           'text/plain' => ['q' => 0.5],
   // ]



    [$header] (string) The header to be parsed


*yii/web/Request::getPreferredLanguage*			public
>
 getPreferredLanguage($languages='[]')
<
return (string) The language that the application should use.

 The language resolution is based on the user preferred languages and the
 languages supported by the application. The method will try to find the best
 match.

    [$languages] (array) A list of the languages supported by the application.
    If this is empty, the current application language will be returned
    without further processing.


*yii/web/Request::getETags*				public
>
 getETags()
<
return (array) The entity tags



*yii/web/Request::getCookies*				public
>
 getCookies()
<
return (\yii\web\CookieCollection) The cookie collection.

 Through the returned cookie collection, you may access a cookie using the
 following syntax:

   $cookie = $request->cookies['name']
   if ($cookie !== null) {
       $value = $cookie->value;
   }

   // alternatively
   $value = $request->cookies->getValue('name');




*yii/web/Request::loadCookies*				protected
>
 loadCookies()
<
return (array) The cookies obtained from request



*yii/web/Request::getCsrfToken*				public
>
 getCsrfToken($regenerate='false')
<
return (string) The token used to perform CSRF validation.

 This token is generated in a way to prevent [BREACH
 attacks](http://breachattack.com/). It may be passed along via a hidden field
 of an HTML form or an HTTP header value to support CSRF validation.

    [$regenerate] (bool) Whether to regenerate CSRF token. When this parameter
    is true, each time this method is called, a new CSRF token will be
    generated and persisted (in session or cookie).


*yii/web/Request::loadCsrfToken*				protected
>
 loadCsrfToken()
<
return (string) The CSRF token loaded from cookie or session. Null is returned if the
cookie or session does not have CSRF token.



*yii/web/Request::generateCsrfToken*			protected
>
 generateCsrfToken()
<
return (string) The random token for CSRF validation.



*yii/web/Request::getCsrfTokenFromHeader*			public
>
 getCsrfTokenFromHeader()
<
return (string) The CSRF token sent via 'CSRF_HEADER' by browser. Null is returned if
no such header is sent.



*yii/web/Request::createCsrfCookie*			protected
>
 createCsrfCookie($token)
<
return (\yii\web\Cookie) The generated cookie

 Initial values specified in 'csrfCookie' will be applied to the generated
 cookie.

    [$token] (string) The CSRF token


*yii/web/Request::validateCsrfToken*			public
>
 validateCsrfToken($clientSuppliedToken='null')
<
return (bool) Whether CSRF token is valid. If 'enableCsrfValidation' is false, this
method will return true.

 This method will validate the user-provided CSRF token by comparing it with
 the one stored in cookie or session. This method is mainly called in
 'Controller::beforeAction()'.

 Note that the method will NOT perform CSRF validation if
 'enableCsrfValidation' is false or the HTTP method is among GET, HEAD or
 OPTIONS.

    [$clientSuppliedToken] (string) The user-provided CSRF token to be
    validated. If null, the token will be retrieved from the 'csrfParam' POST
    field or HTTP header. This parameter is available since version 2.0.4.



 vim:tw=78:ts=8:ft=help:norl:
