
*yii/helpers/BaseSecurity*  
==========================

SUBCLASSES
------------------------------------------------------------------------------

|yii/helpers/Security|

DESCRIPTION
------------------------------------------------------------------------------

 Do not use BaseSecurity. Use 'Security' instead.



METHOD DETAILS
------------------------------------------------------------------------------

*yii/helpers/BaseSecurity::encrypt*			public
>
 encrypt($data, $password)
<
(string) The encrypted data

    [$data] (string) Data to be encrypted.
    [$password] (string) The encryption password


*yii/helpers/BaseSecurity::decrypt*			public
>
 decrypt($data, $password)
<
(string) The decrypted data

    [$data] (string) Data to be decrypted.
    [$password] (string) The decryption password


*yii/helpers/BaseSecurity::addPadding*			protected
>
 addPadding($data)
<
(string) The padded data

    [$data] (string) The data to pad


*yii/helpers/BaseSecurity::stripPadding*			protected
>
 stripPadding($data)
<
(string) The trimmed data

    [$data] (string) The data to trim


*yii/helpers/BaseSecurity::deriveKey*			protected
>
 deriveKey($password, $salt)
<
(string) The derived key

    [$password] (string) The source password
    [$salt] (string) The random salt


*yii/helpers/BaseSecurity::hashData*			public
>
 hashData($data, $key, $algorithm=''sha256'')
<
(string) The data prefixed with the keyed hash

    [$data] (string) The data to be protected
    [$key] (string) The secret key to be used for generating hash
    [$algorithm] (string) The hashing algorithm (e.g. "md5", "sha1", "sha256",
    etc.). Call PHP "hash_algos()" function to see the supported hashing
    algorithms on your system.


*yii/helpers/BaseSecurity::validateData*			public
>
 validateData($data, $key, $algorithm=''sha256'')
<
(string) The real data with the hash stripped off. False if the data is
tampered.

    [$data] (string) The data to be validated. The data must be previously
    generated by 'hashData()'.
    [$key] (string) The secret key that was previously used to generate the
    hash for the data in 'hashData()'.
    [$algorithm] (string) The hashing algorithm (e.g. "md5", "sha1", "sha256",
    etc.). Call PHP "hash_algos()" function to see the supported hashing
    algorithms on your system. This must be the same as the value passed to
    'hashData()' when generating the hash for the data.


*yii/helpers/BaseSecurity::getSecretKey*			public
>
 getSecretKey($name, $length=32)
<
(string) The secret key associated with the specified name

 If the secret key does not exist, a random key will be generated and saved in
 the file "keys.json" under the application's runtime directory so that the
 same secret key can be returned in future requests.
    [$name] (string) The name that is associated with the secret key
    [$length] (integer) The length of the key that should be generated if not
    exists


*yii/helpers/BaseSecurity::generateRandomKey*		public
>
 generateRandomKey($length=32)
<
(string) The generated random key

    [$length] (integer) The length of the key that should be generated


*yii/helpers/BaseSecurity::openCryptModule*		protected
>
 openCryptModule()
<
(resource) The mcrypt module handle.



*yii/helpers/BaseSecurity::generatePasswordHash*		public
>
 generatePasswordHash($password, $cost=13)
<
(string) The password hash string, ASCII and not longer than 64 characters.

 The generated hash can be stored in database (e.g. 'CHAR(64) CHARACTER SET
 latin1' on MySQL). Later when a password needs to be validated, the hash can
 be fetched and passed to 'validatePassword()'. For example,

   // generates the hash (usually done during user registration or when the
 password is changed)
   $hash = Security::generatePasswordHash($password);
   // ...save $hash in database...

   // during login, validate if the password entered is correct using $hash
 fetched from database
   if (Security::validatePassword($password, $hash) {
       // password is good
   } else {
       // password is bad
   }


    [$password] (string) The password to be hashed.
    [$cost] (integer) Cost parameter used by the Blowfish hash algorithm. The
    higher the value of cost, the longer it takes to generate the hash and to
    verify a password against it. Higher cost therefore slows down a
    brute-force attack. For best protection against brute for attacks, set it
    to the highest value that is tolerable on production servers. The time
    taken to compute the hash doubles for every increment by one of $cost. So,
    for example, if the hash takes 1 second to compute when $cost is 14 then
    then the compute time varies as 2^($cost 
      - 14) seconds.


*yii/helpers/BaseSecurity::validatePassword*		public
>
 validatePassword($password, $hash)
<
(boolean) Whether the password is correct.

    [$password] (string) The password to verify.
    [$hash] (string) The hash to verify the password against.


*yii/helpers/BaseSecurity::generateSalt*			protected
>
 generateSalt($cost=13)
<
(string) The random salt value.

 The PHP [crypt()](http://php.net/manual/en/function.crypt.php) built-in
 function requires, for the Blowfish hash algorithm, a salt string in a
 specific format: "$2a$", "$2x$" or "$2y$", a two digit cost parameter, "$",
 and 22 characters from the alphabet "./0-9A-Za-z".
    [$cost] (integer) The cost parameter



 vim:tw=78:ts=8:ft=help:norl:
