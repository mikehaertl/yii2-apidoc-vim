
*yii/db/QueryBuilder*   >> |yii/base/Object|
=====================

SUBCLASSES
------------------------------------------------------------------------------

|yii/db/sqlite/QueryBuilder|
|yii/db/mssql/QueryBuilder|
|yii/db/mysql/QueryBuilder|
|yii/db/pgsql/QueryBuilder|
|yii/db/oci/QueryBuilder|
|yii/db/cubrid/QueryBuilder|

DESCRIPTION
------------------------------------------------------------------------------

 QueryBuilder can also be used to build SQL statements such as INSERT, UPDATE,
 DELETE, CREATE TABLE, from a 'Query' object.


PROPERTY DETAILS
------------------------------------------------------------------------------

$db					*yii/db/QueryBuilder::$db*
 (\yii\db\Connection) The database connection.

$separator				*yii/db/QueryBuilder::$separator*
 (string) The separator between different fragments of a SQL statement.
 Defaults to an empty space. This is mainly used by 'build()' when generating
 a SQL statement.

$typeMap				*yii/db/QueryBuilder::$typeMap*
 (array) The abstract column types mapped to physical column types. This is
 mainly used to support creating/modifying tables using DB-independent data
 type specifications. Child classes should override this property to declare
 supported type mappings.

$conditionBuilders			*yii/db/QueryBuilder::$conditionBuilders*
 (array) Map of query condition to builder methods. These methods are used by
 'buildCondition' to build SQL conditions from array syntax.



METHOD DETAILS
------------------------------------------------------------------------------

*yii/db/QueryBuilder::className*				public
 See |yii/base/Object::className|


*yii/db/QueryBuilder::__construct*			public
>
 __construct($connection, $config='[]')
<
(void)

    [$connection] (\yii\db\Connection) The database connection.
    [$config] (array) Name-value pairs that will be used to initialize the
    object properties


*yii/db/QueryBuilder::init*				public
 See |yii/base/Object::init|


*yii/db/QueryBuilder::__get*				public
 See |yii/base/Object::__get|


*yii/db/QueryBuilder::__set*				public
 See |yii/base/Object::__set|


*yii/db/QueryBuilder::__isset*				public
 See |yii/base/Object::__isset|


*yii/db/QueryBuilder::__unset*				public
 See |yii/base/Object::__unset|


*yii/db/QueryBuilder::__call*				public
 See |yii/base/Object::__call|


*yii/db/QueryBuilder::hasProperty*			public
 See |yii/base/Object::hasProperty|


*yii/db/QueryBuilder::canGetProperty*			public
 See |yii/base/Object::canGetProperty|


*yii/db/QueryBuilder::canSetProperty*			public
 See |yii/base/Object::canSetProperty|


*yii/db/QueryBuilder::hasMethod*				public
 See |yii/base/Object::hasMethod|


*yii/db/QueryBuilder::build*				public
>
 build($query, $params='[]')
<
(array) The generated SQL statement (the first array element) and the
corresponding parameters to be bound to the SQL statement (the second array
element). The parameters returned include those provided in '$params'.

    [$query] (\yii\db\Query) The 'Query' object from which the SQL statement
    will be generated.
    [$params] (array) The parameters to be bound to the generated SQL
    statement. These parameters will be included in the result with the
    additional parameters generated during the query building process.


*yii/db/QueryBuilder::insert*				public
>
 insert($table, $columns, $params)
<
(string) The INSERT SQL

 For example,

   $sql = $queryBuilder->insert('user', [
    'name' => 'Sam',
    'age' => 30,
   ], $params);

 The method will properly escape the table and column names.
    [$table] (string) The table that new rows will be inserted into.
    [$columns] (array) The column data (name => value) to be inserted into the
    table.
    [$params] (array) The binding parameters that will be generated by this
    method. They should be bound to the DB command later.


*yii/db/QueryBuilder::batchInsert*			public
>
 batchInsert($table, $columns, $rows)
<
(string) The batch INSERT SQL statement

 For example,

   $sql = $queryBuilder->batchInsert('user', ['name', 'age'], [
       ['Tom', 30],
       ['Jane', 20],
       ['Linda', 25],
   ]);

 Note that the values in each row must match the corresponding column names.
    [$table] (string) The table that new rows will be inserted into.
    [$columns] (array) The column names
    [$rows] (array) The rows to be batch inserted into the table


*yii/db/QueryBuilder::update*				public
>
 update($table, $columns, $condition, $params)
<
(string) The UPDATE SQL

 For example,

   $params = [];
   $sql = $queryBuilder->update('user', ['status' => 1], 'age > 30', $params);

 The method will properly escape the table and column names.
    [$table] (string) The table to be updated.
    [$columns] (array) The column data (name => value) to be updated.
    [$condition] (array|string) The condition that will be put in the WHERE
    part. Please refer to 'Query::where()' on how to specify condition.
    [$params] (array) The binding parameters that will be modified by this
    method so that they can be bound to the DB command later.


*yii/db/QueryBuilder::delete*				public
>
 delete($table, $condition, $params)
<
(string) The DELETE SQL

 For example,

   $sql = $queryBuilder->delete('user', 'status = 0');

 The method will properly escape the table and column names.
    [$table] (string) The table where the data will be deleted from.
    [$condition] (array|string) The condition that will be put in the WHERE
    part. Please refer to 'Query::where()' on how to specify condition.
    [$params] (array) The binding parameters that will be modified by this
    method so that they can be bound to the DB command later.


*yii/db/QueryBuilder::createTable*			public
>
 createTable($table, $columns, $options='null')
<
(string) The SQL statement for creating a new DB table.

 The columns in the new  table should be specified as name-definition pairs
 (e.g. 'name' => 'string'), where name stands for a column name which will be
 properly quoted by the method, and definition stands for the column type
 which can contain an abstract DB type. The 'getColumnType()' method will be
 invoked to convert any abstract type into a physical one.

 If a column is specified with definition only (e.g. 'PRIMARY KEY (name,
 type)'), it will be directly inserted into the generated SQL.

 For example,

   $sql = $queryBuilder->createTable('user', [
    'id' => 'pk',
    'name' => 'string',
    'age' => 'integer',
   ]);


    [$table] (string) The name of the table to be created. The name will be
    properly quoted by the method.
    [$columns] (array) The columns (name => definition) in the new table.
    [$options] (string) Additional SQL fragment that will be appended to the
    generated SQL.


*yii/db/QueryBuilder::renameTable*			public
>
 renameTable($oldName, $newName)
<
(string) The SQL statement for renaming a DB table.

    [$oldName] (string) The table to be renamed. The name will be properly
    quoted by the method.
    [$newName] (string) The new table name. The name will be properly quoted
    by the method.


*yii/db/QueryBuilder::dropTable*				public
>
 dropTable($table)
<
(string) The SQL statement for dropping a DB table.

    [$table] (string) The table to be dropped. The name will be properly
    quoted by the method.


*yii/db/QueryBuilder::addPrimaryKey*			public
>
 addPrimaryKey($name, $table, $columns)
<
(string) The SQL statement for adding a primary key constraint to an existing
table.

    [$name] (string) The name of the primary key constraint.
    [$table] (string) The table that the primary key constraint will be added
    to.
    [$columns] (string|array) Comma separated string or array of columns that
    the primary key will consist of.


*yii/db/QueryBuilder::dropPrimaryKey*			public
>
 dropPrimaryKey($name, $table)
<
(string) The SQL statement for removing a primary key constraint from an
existing table.

    [$name] (string) The name of the primary key constraint to be removed.
    [$table] (string) The table that the primary key constraint will be
    removed from.


*yii/db/QueryBuilder::truncateTable*			public
>
 truncateTable($table)
<
(string) The SQL statement for truncating a DB table.

    [$table] (string) The table to be truncated. The name will be properly
    quoted by the method.


*yii/db/QueryBuilder::addColumn*				public
>
 addColumn($table, $column, $type)
<
(string) The SQL statement for adding a new column.

    [$table] (string) The table that the new column will be added to. The
    table name will be properly quoted by the method.
    [$column] (string) The name of the new column. The name will be properly
    quoted by the method.
    [$type] (string) The column type. The 'getColumnType()' method will be
    invoked to convert abstract column type (if any) into the physical one.
    Anything that is not recognized as abstract type will be kept in the
    generated SQL. For example, 'string' will be turned into 'varchar(255)',
    while 'string not null' will become 'varchar(255) not null'.


*yii/db/QueryBuilder::dropColumn*				public
>
 dropColumn($table, $column)
<
(string) The SQL statement for dropping a DB column.

    [$table] (string) The table whose column is to be dropped. The name will
    be properly quoted by the method.
    [$column] (string) The name of the column to be dropped. The name will be
    properly quoted by the method.


*yii/db/QueryBuilder::renameColumn*			public
>
 renameColumn($table, $oldName, $newName)
<
(string) The SQL statement for renaming a DB column.

    [$table] (string) The table whose column is to be renamed. The name will
    be properly quoted by the method.
    [$oldName] (string) The old name of the column. The name will be properly
    quoted by the method.
    [$newName] (string) The new name of the column. The name will be properly
    quoted by the method.


*yii/db/QueryBuilder::alterColumn*			public
>
 alterColumn($table, $column, $type)
<
(string) The SQL statement for changing the definition of a column.

    [$table] (string) The table whose column is to be changed. The table name
    will be properly quoted by the method.
    [$column] (string) The name of the column to be changed. The name will be
    properly quoted by the method.
    [$type] (string) The new column type. The 'getColumnType()' method will be
    invoked to convert abstract column type (if any) into the physical one.
    Anything that is not recognized as abstract type will be kept in the
    generated SQL. For example, 'string' will be turned into 'varchar(255)',
    while 'string not null' will become 'varchar(255) not null'.


*yii/db/QueryBuilder::addForeignKey*			public
>
 addForeignKey($name, $table, $columns, $refTable, $refColumns, $delete='null', $update='null')
<
(string) The SQL statement for adding a foreign key constraint to an existing
table.

 The method will properly quote the table and column names.
    [$name] (string) The name of the foreign key constraint.
    [$table] (string) The table that the foreign key constraint will be added
    to.
    [$columns] (string|array) The name of the column to that the constraint
    will be added on. If there are multiple columns, separate them with commas
    or use an array to represent them.
    [$refTable] (string) The table that the foreign key references to.
    [$refColumns] (string|array) The name of the column that the foreign key
    references to. If there are multiple columns, separate them with commas or
    use an array to represent them.
    [$delete] (string) The ON DELETE option. Most DBMS support these options:
    RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL
    [$update] (string) The ON UPDATE option. Most DBMS support these options:
    RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL


*yii/db/QueryBuilder::dropForeignKey*			public
>
 dropForeignKey($name, $table)
<
(string) The SQL statement for dropping a foreign key constraint.

    [$name] (string) The name of the foreign key constraint to be dropped. The
    name will be properly quoted by the method.
    [$table] (string) The table whose foreign is to be dropped. The name will
    be properly quoted by the method.


*yii/db/QueryBuilder::createIndex*			public
>
 createIndex($name, $table, $columns, $unique='false')
<
(string) The SQL statement for creating a new index.

    [$name] (string) The name of the index. The name will be properly quoted
    by the method.
    [$table] (string) The table that the new index will be created for. The
    table name will be properly quoted by the method.
    [$columns] (string|array) The column(s) that should be included in the
    index. If there are multiple columns, separate them with commas or use an
    array to represent them. Each column name will be properly quoted by the
    method, unless a parenthesis is found in the name.
    [$unique] (boolean) Whether to add UNIQUE constraint on the created index.


*yii/db/QueryBuilder::dropIndex*				public
>
 dropIndex($name, $table)
<
(string) The SQL statement for dropping an index.

    [$name] (string) The name of the index to be dropped. The name will be
    properly quoted by the method.
    [$table] (string) The table whose index is to be dropped. The name will be
    properly quoted by the method.


*yii/db/QueryBuilder::resetSequence*			public
>
 resetSequence($table, $value='null')
<
(string) The SQL statement for resetting sequence

 The sequence will be reset such that the primary key of the next new row
 inserted will have the specified value or 1.
    [$table] (string) The name of the table whose primary key sequence will be
    reset
    [$value] (array|string) The value for the primary key of the next new row
    inserted. If this is not set, the next new row's primary key will have a
    value 1.


*yii/db/QueryBuilder::checkIntegrity*			public
>
 checkIntegrity($check='true', $schema='''', $table='''')
<
(string) The SQL statement for checking integrity

    [$check] (boolean) Whether to turn on or off the integrity check.
    [$schema] (string) The schema of the tables. Defaults to empty string,
    meaning the current or default schema.
    [$table] (string) The table name. Defaults to empty string, meaning that
    no table will be changed.


*yii/db/QueryBuilder::getColumnType*			public
>
 getColumnType($type)
<
(string) Physical column type.

 The conversion is done using the type map specified in 'typeMap'. The
 following abstract column types are supported (using MySQL as an example to
 explain the corresponding physical types):


   - 'pk': an auto-incremental primary key type, will be converted into
   "int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY" 
   - 'bigpk': an auto-incremental primary key type, will be converted
   into "bigint(20) NOT NULL AUTO_INCREMENT PRIMARY KEY" 
   - 'string': string type, will be converted into "varchar(255)" 
   - 'text': a long string type, will be converted into "text" 
   - 'smallint': a small integer type, will be converted into
   "smallint(6)" 
   - 'integer': integer type, will be converted into "int(11)" 
   - 'bigint': a big integer type, will be converted into "bigint(20)" 
   - 'boolean': boolean type, will be converted into "tinyint(1)" 
   - 'float'': float number type, will be converted into "float" 
   - 'decimal': decimal number type, will be converted into "decimal" 
   - 'datetime': datetime type, will be converted into "datetime" 
   - 'timestamp': timestamp type, will be converted into "timestamp" 
   - 'time': time type, will be converted into "time" 
   - 'date': date type, will be converted into "date" 
   - 'money': money type, will be converted into "decimal(19,4)" 
   - 'binary': binary data type, will be converted into "blob"

 If the abstract type contains two or more parts separated by spaces (e.g.
 "string NOT NULL"), then only the first part will be converted, and the rest
 of the parts will be appended to the converted result. For example, 'string
 NOT NULL' is converted to 'varchar(255) NOT NULL'.

 For some of the abstract types you can also specify a length or precision
 constraint by appending it in round brackets directly to the type. For
 example 'string(32)' will be converted into "varchar(32)" on a MySQL
 database. If the underlying DBMS does not support these kind of constraints
 for a type it will be ignored.

 If a type cannot be found in 'typeMap', it will be returned without any
 change.
    [$type] (string) Abstract column type


*yii/db/QueryBuilder::buildSelect*			public
>
 buildSelect($columns, $params, $distinct='false', $selectOption='null')
<
(string) The SELECT clause built from 'Query::$select'.

    [$columns] (array) 
    [$params] (array) The binding parameters to be populated
    [$distinct] (boolean) 
    [$selectOption] (string) 


*yii/db/QueryBuilder::buildFrom*				public
>
 buildFrom($tables, $params)
<
(string) The FROM clause built from 'Query::$from'.

    [$tables] (array) 
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildJoin*				public
>
 buildJoin($joins, $params)
<
(string) The JOIN clause built from 'Query::$join'.

    [$joins] (array) 
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildWhere*				public
>
 buildWhere($condition, $params)
<
(string) The WHERE clause built from 'Query::$where'.

    [$condition] (string|array) 
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildGroupBy*			public
>
 buildGroupBy($columns)
<
(string) The GROUP BY clause

    [$columns] (array) 


*yii/db/QueryBuilder::buildHaving*			public
>
 buildHaving($condition, $params)
<
(string) The HAVING clause built from 'Query::$having'.

    [$condition] (string|array) 
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildOrderByAndLimit*		public
>
 buildOrderByAndLimit($sql, $orderBy, $limit, $offset)
<
(string) The SQL completed with ORDER BY/LIMIT/OFFSET (if any)

    [$sql] (string) The existing SQL (without ORDER BY/LIMIT/OFFSET)
    [$orderBy] (array) The order by columns. See 'Query::orderBy' for more
    details on how to specify this parameter.
    [$limit] (integer) The limit number. See 'Query::limit' for more details.
    [$offset] (integer) The offset number. See 'Query::offset' for more
    details.


*yii/db/QueryBuilder::buildOrderBy*			public
>
 buildOrderBy($columns)
<
(string) The ORDER BY clause built from 'Query::$orderBy'.

    [$columns] (array) 


*yii/db/QueryBuilder::buildLimit*				public
>
 buildLimit($limit, $offset)
<
(string) The LIMIT and OFFSET clauses

    [$limit] (integer) 
    [$offset] (integer) 


*yii/db/QueryBuilder::hasLimit*				protected
>
 hasLimit($limit)
<
(boolean) Whether the limit is effective

    [$limit] (mixed) The given limit


*yii/db/QueryBuilder::hasOffset*				protected
>
 hasOffset($offset)
<
(boolean) Whether the offset is effective

    [$offset] (mixed) The given offset


*yii/db/QueryBuilder::buildUnion*				public
>
 buildUnion($unions, $params)
<
(string) The UNION clause built from 'Query::$union'.

    [$unions] (array) 
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildColumns*			public
>
 buildColumns($columns)
<
(string) The processing result

 It will join all columns into a string with comma as separators.
    [$columns] (string|array) The columns to be processed


*yii/db/QueryBuilder::buildCondition*			public
>
 buildCondition($condition, $params)
<
(string) The generated SQL expression

    [$condition] (string|array) The condition specification. Please refer to
    'Query::where()' on how to specify a condition.
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildHashCondition*			public
>
 buildHashCondition($condition, $params)
<
(string) The generated SQL expression

    [$condition] (array) The condition specification.
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildAndCondition*			public
>
 buildAndCondition($operator, $operands, $params)
<
(string) The generated SQL expression

    [$operator] (string) The operator to use for connecting the given operands
    [$operands] (array) The SQL expressions to connect.
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildNotCondition*			public
>
 buildNotCondition($operator, $operands, $params)
<
(string) The generated SQL expression

    [$operator] (string) The operator to use for connecting the given operands
    [$operands] (array) The SQL expressions to connect.
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildBetweenCondition*		public
>
 buildBetweenCondition($operator, $operands, $params)
<
(string) The generated SQL expression

    [$operator] (string) The operator to use (e.g. 'BETWEEN' or 'NOT BETWEEN')
    [$operands] (array) The first operand is the column name. The second and
    third operands describe the interval that column value should be in.
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildInCondition*			public
>
 buildInCondition($operator, $operands, $params)
<
(string) The generated SQL expression

    [$operator] (string) The operator to use (e.g. 'IN' or 'NOT IN')
    [$operands] (array) The first operand is the column name. If it is an
    array a composite IN condition will be generated. The second operand is an
    array of values that column value should be among. If it is an empty array
    the generated expression will be a 'false' value if operator is 'IN' and
    empty if operator is 'NOT IN'.
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildCompositeInCondition*		protected
>
 buildCompositeInCondition($operator, $columns, $values, $params)
<
(string) SQL

    [$operator] (string) 
    [$columns] (array) 
    [$values] (array) 
    [$params] (array) 


*yii/db/QueryBuilder::buildLikeCondition*			public
>
 buildLikeCondition($operator, $operands, $params)
<
(string) The generated SQL expression

    [$operator] (string) The operator to use (e.g. 'LIKE', 'NOT LIKE', 'OR
    LIKE' or 'OR NOT LIKE')
    [$operands] (array) An array of two or three operands


      - The first operand is the column name. 
      - The second operand is a single value or an array of values that
      column value   should be compared with. If it is an empty array the
    generated expression will   be a 'false' value if operator is 'LIKE' or
    'OR LIKE', and empty if operator   is 'NOT LIKE' or 'OR NOT LIKE'. 
      - An optional third operand can also be provided to specify how to
      escape special characters   in the value(s). The operand should be an
    array of mappings from the special characters to their   escaped
    counterparts. If this operand is not provided, a default escape mapping
    will be used.   You may use 'false' or an empty array to indicate the
    values are already escaped and no escape   should be applied. Note that
    when using an escape mapping (or the third operand is not provided),   the
    values will be automatically enclosed within a pair of percentage
    characters.
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildExistsCondition*		public
>
 buildExistsCondition($operator, $operands, $params)
<
(string) The generated SQL expression

    [$operator] (string) The operator to use (e.g. 'EXISTS' or 'NOT EXISTS')
    [$operands] (array) Contains only one element which is a 'Query' object
    representing the sub-query.
    [$params] (array) The binding parameters to be populated


*yii/db/QueryBuilder::buildSimpleCondition*		public
>
 buildSimpleCondition($operator, $operands, $params)
<
(string) The generated SQL expression

    [$operator] (string) The operator to use. Anything could be used e.g. '>',
    '<=', etc.
    [$operands] (array) Contains two column names.
    [$params] (array) The binding parameters to be populated



 vim:tw=78:ts=8:ft=help:norl:
